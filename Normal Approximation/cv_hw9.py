# -*- coding: utf-8 -*-
"""CV_HW9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l4_NYS-J5363yOETNdaR1QVnsQvqxD_u
"""

from google.colab import drive
# Accessing My Google Drive
drive.mount('/content/drive')

import numpy as np
import cv2 as cv
from numpy import linalg as LA
from matplotlib import pyplot as plt

img_address = "drive/My Drive/dog.jpg"
img = cv.imread(img_address, 0)
# print(img)
# img = img[:,:,0]
plt.imshow(cv.cvtColor(img, cv.COLOR_BGR2RGB))
plt.show()
img

def histogram(data):
  frequency = np.zeros(257)
  for i in range(len(data)):
    for j in range(len(data[0])):
      frequency[data[i][j]] += 1
  plt.plot(frequency)
  plt.show()
  return frequency

histo = histogram(img)
print(img)

import math

def parameters(fre):
  max = 0
  for i in range(0, len(fre)):
    if fre[i] > fre[max]:
      max = i
  medianB = max
  sigmaB = (medianB) / 3
  temp = medianB + (3 * sigmaB)
  if temp < 255 :
    max = 0
    for i in range(int(temp), len(fre)):
      if fre[i] > fre[max]:
        max = i
    medianO = max
    sigmaO = (medianO - temp) / 3
  else : 
    sigmaB = (256 - medianB) / 3
    temp = medianB - (3 * sigmaB)
    max = 0
    for i in range(0, int(temp)):
      if fre[i] > fre[max]:
        max = i
    medianO = max
    sigmaO = (temp - medianO) / 3
  AB = 1 / (math.sqrt(math.pi * 2) * sigmaO)
  AO = 1 / (math.sqrt(math.pi * 2) * sigmaB)
  tempO = AO * sigmaO
  tempB = AB * sigmaB
  teta = tempO / (tempO + tempB)
  return sigmaO, medianO, sigmaB, medianB, teta
  
sigmaO, medianO, sigmaB, medianB, teta = parameters(histo)
print("sigmaO, medianO, sigmaB, medianB, teta : ", sigmaO, medianO, sigmaB, medianB, teta)

from sympy import *
def calculte_t(sigmaO, medianO, sigmaB, medianB, teta):
  x = symbols('x', real=True)
  eO = pow(math.e, -abs((x - medianO)/sigmaO))
  pO = (1 / (2 * sigmaO))* eO
  yek = teta * pO
  eB =  pow(math.e, -abs((x - medianB)/sigmaB))
  pB = (1 / (2 * sigmaB))* eB
  do = (1 - teta) * pB
  expr = -abs((x - medianO)/sigmaO) + abs((x - medianB)/sigmaB)
  t = solve(expr)
  return t

t = calculte_t(sigmaO, medianO, sigmaB, medianB, teta)
print(t)
for i in range(len(t)):
  if t[i] > 0:
    t = t[i]
    break
print("Threshold : ", t)

def calculte_t2(sigmaO, medianO, sigmaB, medianB, teta):
  minus = medianB - medianO
  sum = medianB + medianO
  t= (pow(sigmaO, 2)/minus) * np.log((1 - teta) / teta) - (sum / 2)
  return np.abs(t)

t2 = calculte_t2(sigmaO, medianO, sigmaB, medianB, teta)

def object_detect(img, t):
  detected = np.array(img)
  for i in range(len(img)):
    for j in range(len(img[0])):
      detected[i, j] = 0 if detected[i,j] > t2 else detected[i, j]
  return detected

detected = object_detect(img, t)
plt.imshow(cv.cvtColor(detected, cv.COLOR_BGR2RGB))
plt.show()

